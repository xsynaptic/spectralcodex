---
import type { GetStaticPaths, InferGetStaticPropsType } from 'astro';

import * as R from 'remeda';

import ThemeEntry from '#layouts/theme-entry.astro';
import { getLocationsCollection } from '#lib/collections/locations/locations-data.ts';
import { getFirstRegionByReferenceFunction } from '#lib/collections/regions/regions-utils.ts';
import { getThemesCollection } from '#lib/collections/themes/themes-data.ts';
import { getPostsByThemeFunction } from '#lib/collections/themes/themes-utils.ts';
import { LanguageCodeEnum } from '#lib/i18n/i18n-types.ts';
import { getMapData } from '#lib/map/map-data.ts';
import { getLocationsFeatureCollection } from '#lib/map/map-locations.ts';
import {
	filterHasFeaturedImage,
	getContentMetadataFunction,
	sortContentMetadataByDate,
} from '#lib/metadata/metadata-utils.ts';
import { sortByContentCount } from '#lib/utils/collections.ts';
import { getFilterEntryQualityFunction } from '#lib/utils/collections.ts';
import { getMapApiBaseUrl } from '#lib/utils/routing.ts';

export const getStaticPaths = (async ({ paginate }) => {
	const { locations } = await getLocationsCollection();
	const { themes } = await getThemesCollection();

	const getPostsByTerm = await getPostsByThemeFunction();
	const getContentMetadata = await getContentMetadataFunction();
	const getFirstRegionByReference = await getFirstRegionByReferenceFunction();

	const results = [];

	for (const entry of themes) {
		const regionPrimary = getFirstRegionByReference(entry.data.regions);

		// Note: the need to get location data async means we should filter this first!
		const locationsFiltered = locations.filter(
			({ data }) => data.themes?.some(({ id }) => id === entry.id) ?? false
		);

		const postsFiltered = getPostsByTerm(entry);

		// Metadata items are the posts and locations that are associated with the theme
		const metadataItemsFiltered = R.pipe(
			[
				...R.pipe(
					locationsFiltered,
					R.filter(getFilterEntryQualityFunction(2)) // Quality filter last!
				),
				...postsFiltered,
			],
			getContentMetadata,
			R.filter(filterHasFeaturedImage),
			R.sort(sortContentMetadataByDate)
		);

		// Anything that wasn't included above
		const metadataItemsAll = R.pipe(
			[...locationsFiltered, ...postsFiltered],
			R.filter(({ id }) => !metadataItemsFiltered.some((item) => item.id === id)),
			getContentMetadata,
			R.shuffle()
		);
		const metadataItems = metadataItemsAll.slice(0, 25);
		const metadataItemsCount = metadataItemsAll.length;

		const mapData = getMapData({
			featureCollection: getLocationsFeatureCollection(locationsFiltered),
			mapApiBaseUrl: getMapApiBaseUrl(entry.collection, entry.id),
			...(regionPrimary?.data._langCode?.startsWith('zh')
				? { languages: [LanguageCodeEnum.English, LanguageCodeEnum.ChineseTraditional] }
				: {}),
		});

		// Related themes are those that reference the current theme
		const relatedThemeIds = R.pipe(
			themes,
			R.filter((theme) => theme.data.themes?.some(({ id }) => id === entry.id) ?? false),
			R.sort(sortByContentCount),
			R.map((theme) => theme.id)
		);

		results.push(
			...paginate(metadataItemsFiltered, {
				params: { id: entry.id },
				props: { entry, mapData, metadataItems, metadataItemsCount, relatedThemeIds },
				pageSize: 20,
			})
		);
	}
	return results;
}) satisfies GetStaticPaths;

type Props = InferGetStaticPropsType<typeof getStaticPaths>;
---

<ThemeEntry {...Astro.props} />
